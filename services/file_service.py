import os
import shutil
import stat
import base64
import re
import logging
from typing import List, Dict, Any
from models import Attachment

log = logging.getLogger("uvicorn")

def _onerror(func, path, exc_info):
    """
    Error handler for shutil.rmtree.
    If the error is a permissions error, it attempts to change
    permissions and then re-run the function.
    """
    if exc_info[0] is PermissionError:
        os.chmod(path, stat.S_IWUSR)
        func(path)
    else:
        raise

def prepare_task_directory(task_id: str) -> str:
    """
    Creates a clean, empty directory for the task in /tmp.
    If the directory already exists, it is robustly deleted.
    """
    base_dir = "/tmp/llm_agent_tasks"
    task_dir = os.path.join(base_dir, task_id)
    
    if os.path.exists(task_dir):
        log.info(f"[File] Deleting existing directory: {task_dir}")
        try:
            shutil.rmtree(task_dir, onerror=_onerror)
        except Exception as e:
            log.error(f"[File] CRITICAL: Failed to delete {task_dir}: {e}")
            raise
            
    os.makedirs(task_dir, exist_ok=True)
    log.info(f"[File] Created clean directory: {task_dir}")
    return task_dir

def save_llm_files(task_dir: str, files: List[Dict[str, str]]):
    """
    Saves the files generated by the LLM (e.g., index.html) to the task directory.
    Expects the new [{"path": "...", "content": "..."}] format.
    """
    log.info(f"[File] Saving {len(files)} LLM-generated files to {task_dir}")
    for file_obj in files:
        path = file_obj.get("path")
        content = file_obj.get("content", "")
        
        if not path:
            log.warning("[File] Skipping file with no path.")
            continue
            
        # Ensure content is a string
        if not isinstance(content, str):
            content = str(content)
            
        file_path = os.path.join(task_dir, path)
        
        # Create subdirectories if needed (e.g., "css/style.css")
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        try:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
            log.info(f"  -> Saved: {path} ({len(content)} bytes)")
        except Exception as e:
            log.error(f"  -> FAILED to save {path}: {e}")
            raise

def save_attachment_files(task_dir: str, attachments: List[Attachment]):
    """
    Saves the provided attachments (e.g., data.csv) to the task directory.
    Decodes from Base64 data URI format.
    """
    if not attachments:
        return
        
    log.info(f"[File] Saving {len(attachments)} attachments to {task_dir}")
    for att in attachments:
        try:
            # Find the start of the base64 data
            match = re.search(r"base64,(.*)", att.url, re.IGNORECASE)
            if not match:
                log.warning(f"  -> Skipping {att.name}: Not a valid base64 data URI.")
                continue
                
            base64_data = match.group(1)
            file_bytes = base64.b64decode(base64_data)
            
            file_path = os.path.join(task_dir, att.name)
            with open(file_path, "wb") as f:
                f.write(file_bytes)
            log.info(f"  -> Saved: {att.name} ({len(file_bytes)} bytes)")
            
        except Exception as e:
            log.error(f"  -> FAILED to save attachment {att.name}: {e}")
            # Continue to next attachment but log error
            
def process_attachments_for_llm(attachments: List[Attachment]) -> (List[Dict], List[str]):
    """
    Parses attachments, returning a list of image parts for the LLM
    and a list of all attachment names for the prompt.
    """
    image_parts = []
    all_filenames = []
    
    if not attachments:
        return image_parts, all_filenames

    for att in attachments:
        all_filenames.append(att.name)
        
        # Check if it's an image
        if att.url.startswith("data:image/"):
            try:
                # data:image/png;base64,iVBORw...
                match = re.search(r"data:(?P<mime_type>image/[^;]+);base64,(?P<base64_data>.*)", att.url, re.IGNORECASE)
                if match:
                    image_parts.append({
                        "inlineData": {
                            "mimeType": match.group('mime_type'),
                            "data": match.group('base64_data')
                        }
                    })
            except Exception as e:
                log.warning(f"[LLM] Failed to parse image attachment {att.name}: {e}")

    return image_parts, all_filenames